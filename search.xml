<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[提高组备战计划：Task 1 Day 1]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%8F%90%E9%AB%98%E7%BB%84%E5%A4%87%E6%88%98%E8%AE%A1%E5%88%92%EF%BC%9ATask-1-Day-1%2F</url>
    <content type="text"><![CDATA[最短路复习笔记说在前面NOIP提高组即将来临，而我这个蒟蒻仍在毒瘤出题人的狂轰滥炸下不知所措。 为了在提高组赛场上拿到一个比较满意的成绩，决定开始以七天为单位的算法复习计划。 Day 1 最短路相关算法 Day 2 差分约束系统 Day 3 最小生成树相关算法 Day 4 强连通分量相关算法 Day 5 割点和桥 Day 6 欧拉回路 Day 7 图论模拟赛 图论的模拟赛将在PTOJ上进行。欢迎前来AK或爆0。 概论本文主要讲三种算法。 第一种是Floyd，第二种是DJ，第三种是SPFA。 算法复杂度分别是$O(n^3)$,$O(n^2)$（优化后达到$O(nlogn)$），$O(nm)$。 Part 1 Floyd给人的感觉像是图上的DP。 思路简明易懂，就是基于一个简单的想法： 一个点到另一个点的最短路，要么直接到达，要么经过另几个点。 代码简直呼之欲出。太 显 然 了 。 1234for(int k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) dis[i][j]=min(dis[i][k]+dis[k][j],dis[i][j]); 核心代码奉上。 值得一提的是，这里把k放在最外圈枚举。有兴趣可以想想为什么。抄模板的就算了 完整模板如下：123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9+7;int dis[1005][1005],n,m;void init()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) i==j?dis[i][j]=0:dis[i][j]=inf; return;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); init(); while(m--) &#123; int a,b,l; scanf("%d%d%d",&amp;a,&amp;b,&amp;l); dis[a][b]=l; //dis[b][a]=l; //无向图加一行 &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][k]+dis[k][j],dis[i][j]); int q; scanf("%d",&amp;q); while(q--) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",dis[a][b]==1e9+7?-1:dis[a][b]); &#125; return 0;&#125; Floyd虽然慢，但是也有自己的特长：多源最短路。 虽然它可以解决负边，但它不能解决负环的问题。 Part 2 DJ(Dijkstra)给人的感觉像是图上的贪心。 相对来说常用得多的算法。 每次寻找一个离源点最近的点，在它身上做一次对所有点的更新操作。 这样的更新操作一共是$n-1$次。 核心代码如下：12345678for(int x=0;x&lt;n-1;x++)&#123; int now,temp=1e9+7; for(int i=1;i&lt;=n;i++) if(!vis[i]&amp;&amp;d[i]&lt;temp) now=i; for(int i=1;i&lt;=n;i++) d[i]=min(d[i],dis[v][now]+dis[now][i]);&#125; 由于这种算法的时间复杂度比较高，所以通常使用它的堆优化版本。 邻接矩阵空间复杂度高，所以在以下版本中，我使用了邻接表来存图。 代码中部分变量意义如下： d[i]: 答案数组，从源点到i的最短路长度 vis[i]: 记录是否用过i点的数组 first[i]: 邻接表中存储从i点出发最后一条边的编号的数组 nex:[i] 邻接表中存储编号为i的边的上一条边的数组 ver[i]: 编号为i的边的终点 edge[i]: 编号为i的边的长度123456789101112131415161718192021222324priority_queue&lt;pair&lt;int,int&gt; &gt;q; //记得打空格。。void dijkstra(int st)&#123; memset(d,inf,sizeof(d)); memset(vis,0,sizeof(vis)); d[st]=0; q.push(make_pair(0,st)); while(q.size()) &#123; int x=q.top.second; q.pop(); if(vis[x]) continue; vis[x]=1; for(int i=first[x];i;i=nex[i]) &#123; int y=ver[i],z=edge[i]; if(d[y]&gt;d[x]+z) &#123; d[y]=d[x]+z; q.push(make_pair(-d[y],y)); &#125; &#125; &#125;&#125; 完整代码如下：(LuoguP3371)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e8+7;int n,m,str;int d[10005],vis[10005];int first[10005],nex[500005],ver[500005],edge[500005];priority_queue&lt;pair&lt;int,int&gt; &gt;q; void add_edge(int i,int a,int b,int c)&#123; ver[i]=b; edge[i]=c; nex[i]=first[a]; first[a]=i; return;&#125;void dijkstra(int st)&#123; memset(d,inf,sizeof(d)); memset(vis,0,sizeof(vis)); d[st]=0; q.push(make_pair(0,st)); while(q.size()) &#123; int x=q.top().second; q.pop(); if(vis[x]) continue; vis[x]=1; for(int i=first[x];i;i=nex[i]) &#123; int y=ver[i],z=edge[i]; if(d[x]!=inf&amp;&amp;z!=inf&amp;&amp;d[y]&gt;d[x]+z) &#123; d[y]=d[x]+z; q.push(make_pair(-d[y],y)); &#125; &#125; &#125; return;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;str); for(int i=1;i&lt;=m;i++) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); add_edge(i,a,b,c); &#125; dijkstra(str); for(int i=1;i&lt;=n;i++) printf("%d ",d[i]&gt;=inf?2147483647:d[i]); return 0;&#125; 这货我还看错题把无法到达的情况写炸了一次 堆优化之后，Dijkstra的复杂度优化到了不错的$O((n+m)logn)$，相当好使。 Part 3 SPFA我咕了]]></content>
  </entry>
  <entry>
    <title><![CDATA[暑假科学研究性学习报告]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%9A%91%E5%81%87%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[光在曲面上的折射与反射7203 马正陌 暑期研究性学习报告 背景阐述学初一下学期第二单元时，学习了有关于反射与折射的知识。当时老师在画光路图的时候，给了一个结论： 作光路图时，对于一个半圆形的透明玻璃块，从它的圆心射入的光线会不受折射，原样射出。 在学习漫反射的过程中，老师在一个球面上画的光路图也似乎有一些特殊的性质。 由于没有学过光在曲面上的反射性质，觉得非常神奇。于是把研究性学习的题目定为光在曲面上的折射与反射。 初步想法想法其实在老师刚刚讲完特殊折射时就已经有了。 因为反射和折射都基于一个平面来进行，认为曲面上的折射与反射也应该有自己的一个“假想平面”。既然最简单的例子是球形，那么，第一个念头就是：切面。 这个假设至少是具有几何美的。只过一个切点的面，很可能就是光的反/折射面。这个切点也只能是光线照射的那个点。 解决的办法是：先从一些简单的曲面着手（例如球面、抛物面）开始实验，然后进行假设的验证和推广。 科学原理光在均匀介质中的传播性质。 实验方案 反射实验采用一个绘有极坐标系的板与弯曲的条状面镜来做。 折射实验采用一个绘有极坐标系的板与半圆形玻璃砖来做。 成果展示：数据器材有限，均以球面镜为准。 数据均三次测量取平均值。 凹面镜 入射角 反射角 15° 15° 30° 30° 45° 45° 60° 60° 75° 75° 90° 90° 凸面镜 入射角 反射角 15° 15° 30° 30° 45° 45° 60° 60° 75° 75° 90° 90° 凹透镜 入射角 反射角 15° 15° 30° 30° 45° 45° 60° 60° 75° 75° 90° 90° 凸透镜 入射角 反射角 15° 15° 30° 30° 45° 45° 60° 60° 75° 75° 90° 90° 成果展示：推论首先发现的是曲面上的折射与反射光线仍与入射光线处于同一平面内。 既然处于同一平面内，那么就可以使用一个平面直角坐标系来描述。 注意到“假想面”是切面（放到光线所在平面内就是切线），那么有以下推论： 设原曲线为$f(x)$，它的导函数为$f’(x)$ 设入射光线与原曲线交点为$(x_0,y_0)$，则切线的斜率为$f’(x_0)$ 则容易求得过$x_0$的切线的表达式为$y=f’(x_0)x+y_0-f’(x_0)x_0$ 则法线的表达式为$y=\frac{1}{f’(x_0)}x+y_0-f’(x_0)x_0$ 已知入射角$\alpha$，则根据法线和折射率$k$可以作出反射角$\beta$和折射角$\gamma$ 这里有$\beta=\alpha$，$\gamma=\alpha{k}$ 以上为在平面内作光路图的一般作法。 研究后反思]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于链式前向星的笔记]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%85%B3%E4%BA%8E%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[链式前向星学习笔记链式前向星是一种非常常见且高效的一种存图方法，在LCA/SPFA等算法中很常用，由于我太弱了，所以需要写一篇Blog来理解它的用法。 需要申明的数组End[i]:第i号边指向的点 Len[i]：第i号边的长度 Next[i]：跟第i号边有相同起点的上一条边的编号 Last[x]：以x为起点的最新一条边的编号 注 ： 在End[i]、Next[i]和Len[i]中，i表示的是第i号边， 而在Last[x]中，x表示的是第x号点； 在Next[i]和Last[x]中存的是边的编号，而在End[i]中存的是点的编号； 边的编号由输入顺序决定，点的编号由输入数据决定； 此处均以有向图讨论，无向图只需要将一条边拆分成两条有向边来存即可； 所有数组的初值均赋为0。 CODE TIME!存图代码：1234567891011//输入n，下面n行输入三个数字，x，y，z，表示从x到y有一条长度为z的边scanf("%d",&amp;n);for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); End[i] = y; Len[i] = z; Next[i] = Last[x];//注意此行与下一行的顺序 //因为Last[i]存的是以x为起点的上一条最新的边，所以此时以x为起点是上一条边 == 目前的Last[x] Last[x] = i;//更新，保证Last[i]始终存的是最新一条边的编号&#125; 输出从点x出发的边:1234567int i=Last[x];//找到最新的一条以x为起点的边 while(i) &#123; //如果有以x为起点的边，则i != 0，则循环继续 printf("%d%d%d\n",x,End[i],Len[i]);//输出起点，终点，长度 i=Next[i];//将i更新为同i一个起点的上一条边，直到 i==0（没有上一条边，循环结束） //若i!=0，则循环继续 &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[寒露]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%AF%92%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[正文你好，寒露。秋天的一个早上，我在校园的小路忽然与你相遇。你在披针形草叶末梢一颗半凝的霜露里，你在迎面吹来的乍寒的晨风里，你在从梧桐树上旋转着落下的一片枯叶里。你带着嗖嗖的寒意，让我把手插在裤兜里，不想和你打个招呼。“坏天气为什么这么早就到来了啊！”我甚至这么想，紧了紧校服外套。我还在怀念着夏天的明亮与热烈，到海边去的碧海蓝天与欢乐时光，想念着冰淇凌和西瓜。——就像不知道为什么，才刚刚算是迈进少年，我就开始怀念童年。 你好，寒露。走在校园的小路上，我有那么点儿“思绪万千”。我从小读着“秋天来了，大雁往南飞，一会儿排成一个一字，一会儿排成一个人字”，但其实，我从来没见过真正的大雁在天空飞。我对很多事情的理解，都很直接地进入了抽象概念。就像你，当我把校服紧一紧时，我想的是：“寒露，你是二十四节气中的第十七个。”但是你不服从我的数学总结，你是那么执着地提醒我的感官：温度低，湿度高。虽然我的手插在兜里，但是你沾在我的鼻尖上，让我忍不住打了个喷嚏。 你好，寒露。我觉得在你清肃的外表下，是不是也藏着点儿调皮？你是不是发现了我的偏见，并且下决心提醒我：时间的每一段，每一格，乃至每个无限小的点，都有它们各自的美和意义？夏天是无忧无虑的，而秋天是清醒冷静的。你把感受引向思考，引向环环迭代的澄思寂虑；而不是引向沉迷，引向层层嵌套的醉生梦死。我想起读过的里尔克的诗：“谁此时没有房子，就不必建造 / 谁此时孤独，就永远孤独”，还想起些关于寒露的中国古诗，它们也表现了孤独，以及思念。人总是必须在孤独中寻找自我，也必须在思念中寻找同类。 你好，寒露。秋天的一个早上，我在校园的小路里忽然与你相遇。我现在有点抱歉说你是“坏天气”了，我来了个深呼吸，把自己卷进晚秋清寒的空气。太阳升起，阳光一转眼就要收走草叶上的那颗凝露。时间是一个铁面无私的家伙，它无情地剥夺一切的存在：不止是一颗露珠，还有生命，还有记忆，思想……然而，我们的文化创造出一根美丽的标尺来丈量它，不试图违抗，不试图扭转，而是以一种审美的态度面对自己在时间面前脆弱的一生。 你好，寒露。谢谢你给我的这个美好早晨，那么，就让我把这些“思绪”记下，作为送给你的一份，小小礼物。 To：各位看官修改完毕，基本上定稿了。我的文笔实在挺烂的。希望没有辣到你们的眼睛（请勿ctrl+A&amp;ctrl+C生而为人，我很抱歉]]></content>
      <tags>
        <tag>Essays</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I'm Here now!]]></title>
    <url>%2F2019%2F03%2F09%2FI-m-Here-now%2F</url>
    <content type="text"><![CDATA[emmmm…I’m just here =)I’m the most stupid student all over the world!哦不好水啊]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
</search>
