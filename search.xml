<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[提高组备战计划：Task 1 Day 3]]></title>
    <url>%2F2019%2F07%2F31%2F%E6%8F%90%E9%AB%98%E7%BB%84%E5%A4%87%E6%88%98%E8%AE%A1%E5%88%92%EF%BC%9ATask-1-Day-3%2F</url>
    <content type="text"><![CDATA[最小生成树相关算法概论讲道理这玩意儿比最短路简单 生成树的定义 在一个$|V|$个点的无向连通图中，取其中的$|V|-1$条边，并连接所有的顶点，所得到的子图称之为原图的一棵生成树。 树的属性树是图的一种特殊形态。图$G$是树当且仅当满足以下的任意一个条件： $G$有$|V|-1$条边，无环； $G$有$|V|-1$条边，无环； 任意两点之间只有唯一的简单路径； $G$连通，但删掉任意一条边就不连通。最小生成树最小生成树就是边权和最小的生成树。最小边原则图中权值最小的边（如果唯一）一定在最小生成树上。唯一性定理对于一个图$G$，若其边权值各不相同，则最小生成树是唯一的。 反之不然。 Part 1: Prim是个贪心算法。 算法流程把整张图所有的点$V$分成两个点集$V_A$和$V_B$。 其中$V_A$中的点是已经接入最小生成树的点，$V_B$则尚未接入。 先随便拿一个点$V_0$，从他开始进行最小生成树。 初始化$d$数组。其中$d[V_0]$是$0$，其它的设为$inf$。 d数组的意思是$V_B$中的点到$V_A$的最短距离。 然后每次选一个$V_B$中的点$V_i$，且$d[V_i]$尽可能小； 答案（生成树大小）加上$d[V_i]$； 把它塞进$V_A$里面，更新$d$数组。跑路。 核心代码存图方式是邻接矩阵。1234567891011121314151617181920212223242526int prim(int v0)&#123; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) d[i]=inf; d[v0]=0; int ans=0,vi; for(int i=1;i&lt;=n;i++) &#123; int minn=inf; for(int j=1;j&lt;=n;j++) &#123; if(!vis[j]&amp;&amp;minn&gt;d[j]) &#123; minn=d[j]; vi=j; &#125; &#125; vis[vi]=1; ans+=d[vi]; for(int j=1;i&lt;=n;j++) &#123; if(!vis[j]%%d[j]&gt;g[k][j]) d[j]=g[k][j]; &#125; &#125; return ans;&#125; 这货和DJ一样，可以使用堆优化的技巧。优化后的复杂度为$O((n+m)logm)$。 模板代码1我咕了]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高组备战计划：Task 1 Day 2]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%8F%90%E9%AB%98%E7%BB%84%E5%A4%87%E6%88%98%E8%AE%A1%E5%88%92%EF%BC%9ATask-1-Day-2%2F</url>
    <content type="text"><![CDATA[差分约束系统复习算法简介 差分约束系统是一种特殊的$N$元一次不等式组，它包含$N$个变量$X_1 \cdots X_N$以及$M$个约束条件，每个约束条件形如$X_i-X_j \le c_k$，其中$c_k$是给定的常数，$1\le i,j\le N,1\le k\le M$。我们要解决的问题是：求一组解$X_1=a_1,X_2=a_2\cdots X_n=a_n$，使所有的约束条件都得到满足。 上面这段话是定义以及问题。 问题是这玩意儿和图论就像土豆学家$Van$和哲学家$Van$一样，完全没有关系。 但强大的人类硬是扯出来了它与单源最短路径（SPFA）之间的联系，并运用图论知识解决了问题。 注意到每个约束条件都可以变形成$X_i\le X_j+c_k$，这与单元最短路径中的一个不等式十分相似。1234if(d[y]&gt;d[x]+z) &#123; //balabalabala&#125; 所以，我们可以把每个变量$X_i$当成有向图中的一个节点$i$，对于每个约束条件$X_i-X_j \le c_k$，就从$j$到$i$连一条长度为$c_k$的有向边。 注意到，如果$\{a_1,a_2\cdots a_n\}$是一组解，那么对于任意的常数$d$，把所有的元素全部加上$d$仍然是一组解。 由于题目中一般会让我们求最小非负数解，所以在处理完了整个系统后要记得将答案减去原解中的最小值。 一道例题这个算法也没什么好多说的了。最重要的还是理解做法，以及能够观察出题目的考点。 差分约束系统的题一般来说不会太变态，但写不出来正解就很难骗分。 例1题目：LuoguP1250 首先要想办法把题目中的条件转化成差分约束能解决的形式。 首先，有关于源点的约定： s_i-s_{n+1}\le 0看到区间就想到前缀和。显然地，可以把题目条件作如下转换： s_v-s_{u-1}\ge c_i两边乘上$-1$就是： s_{u-1}-s_v\le -c_i其中$s_i$为到第$i$个位置的前缀和。 然后，因为一个位置只能种一棵树，所以还有一些约束： 0 \le s_u-s_{u-1}\le 1题目要求的就是$s_n$，所以跑一遍差分约束然后输出$d_n$就好啦~(≧▽≦)/~ 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9+7;int n,m,str;int d[30005];bool vis[30005];int first[30005],nex[500005],ver[500005],edge[500005];void add_edge(int num,int u,int v,int l)&#123; ver[num]=v; edge[num]=l; nex[num]=first[u]; first[u]=num; return;&#125;void spfa(int st)&#123; for(int i=0;i&lt;=n+1;i++) d[i]=inf; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; vis[st]=1,d[st]=0; q.push(st); while(q.size()) &#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=first[x];i;i=nex[i]) &#123; int y=ver[i],z=edge[i]; if(d[y]&gt;d[x]+z) &#123; d[y]=d[x]+z; if(vis[y]==0) q.push(y),vis[y]=1; &#125; &#125; &#125; return; &#125;int main()&#123; int cnt=1; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) add_edge(cnt++,n+1,i,0); for(int i=1;i&lt;=m;i++) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); add_edge(cnt++,b,a-1,-c); &#125; for(int i=1;i&lt;=n;i++) &#123; add_edge(cnt++,i-1,i,1); add_edge(cnt++,i,i-1,0); &#125; spfa(n+1); int minn=inf; for(int i=0;i&lt;=n;i++) minn=min(minn,d[i]); cout&lt;&lt;d[n]-minn; return 0;&#125; 算法总结差分约束系统的难点不在于模板，而在于建图。 多做一些题，锻炼题感才能做出来呐！]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高组备战计划：Task 1 Day 1]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%8F%90%E9%AB%98%E7%BB%84%E5%A4%87%E6%88%98%E8%AE%A1%E5%88%92%EF%BC%9ATask-1-Day-1%2F</url>
    <content type="text"><![CDATA[最短路复习笔记说在前面NOIP提高组即将来临，而我这个蒟蒻仍在毒瘤出题人的狂轰滥炸下不知所措。 为了在提高组赛场上拿到一个比较满意的成绩，决定开始以七天为单位的算法复习计划。 Day 1 最短路相关算法 Day 2 差分约束系统 Day 3 最小生成树相关算法 Day 4 强连通分量相关算法 Day 5 割点和桥 Day 6 欧拉回路 Day 7 图论模拟赛 图论的模拟赛将在PTOJ上进行。欢迎前来AK或爆0。 概论本文主要讲三种算法。 第一种是Floyd，第二种是DJ，第三种是SPFA。 算法复杂度分别是$O(n^3)$,$O(n^2)$（优化后达到$O(nlogn)$），$O(nm)$。 Part 1 Floyd给人的感觉像是图上的DP。 思路简明易懂，就是基于一个简单的想法： 一个点到另一个点的最短路，要么直接到达，要么经过另几个点。 代码简直呼之欲出。太 显 然 了 。 1234for(int k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) dis[i][j]=min(dis[i][k]+dis[k][j],dis[i][j]); 核心代码奉上。 值得一提的是，这里把k放在最外圈枚举。有兴趣可以想想为什么。抄模板的就算了 完整模板如下：123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9+7;int dis[1005][1005],n,m;void init()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) i==j?dis[i][j]=0:dis[i][j]=inf; return;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); init(); while(m--) &#123; int a,b,l; scanf("%d%d%d",&amp;a,&amp;b,&amp;l); dis[a][b]=l; //dis[b][a]=l; //无向图加一行 &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][k]+dis[k][j],dis[i][j]); int q; scanf("%d",&amp;q); while(q--) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",dis[a][b]==1e9+7?-1:dis[a][b]); &#125; return 0;&#125; Floyd虽然慢，但是也有自己的特长：多源最短路。 虽然它可以解决负边，但它不能解决负环的问题。 Part 2 DJ(Dijkstra)给人的感觉像是图上的贪心。 相对来说常用得多的算法。 每次寻找一个离源点最近的点，在它身上做一次对所有点的更新操作。 这样的更新操作一共是$n-1$次。 核心代码如下：12345678for(int x=0;x&lt;n-1;x++)&#123; int now,temp=1e9+7; for(int i=1;i&lt;=n;i++) if(!vis[i]&amp;&amp;d[i]&lt;temp) now=i; for(int i=1;i&lt;=n;i++) d[i]=min(d[i],dis[v][now]+dis[now][i]);&#125; 由于这种算法的时间复杂度比较高，所以通常使用它的堆优化版本。 邻接矩阵空间复杂度高，所以在以下版本中，我使用了邻接表来存图。 代码中部分变量意义如下： d[i]: 答案数组，从源点到i的最短路长度 vis[i]: 记录是否用过i点的数组 first[i]: 邻接表中存储从i点出发最后一条边的编号的数组 nex:[i] 邻接表中存储编号为i的边的上一条边的数组 ver[i]: 编号为i的边的终点 edge[i]: 编号为i的边的长度 123456789101112131415161718192021222324priority_queue&lt;pair&lt;int,int&gt; &gt;q; //记得打空格。。void dijkstra(int st)&#123; memset(d,inf,sizeof(d)); memset(vis,0,sizeof(vis)); d[st]=0; q.push(make_pair(0,st)); while(q.size()) &#123; int x=q.top.second; q.pop(); if(vis[x]) continue; vis[x]=1; for(int i=first[x];i;i=nex[i]) &#123; int y=ver[i],z=edge[i]; if(d[y]&gt;d[x]+z) &#123; d[y]=d[x]+z; q.push(make_pair(-d[y],y)); &#125; &#125; &#125;&#125; 完整代码如下：(LuoguP3371)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9+7;int n,m,str;int d[10005],vis[10005];int first[10005],nex[500005],ver[500005],edge[500005];priority_queue&lt;pair&lt;int,int&gt; &gt;q; void add_edge(int i,int a,int b,int c)&#123; ver[i]=b; edge[i]=c; nex[i]=first[a]; first[a]=i; return;&#125;void dijkstra(int st)&#123; for(int i=1;i&lt;=n;i++) d[i]=inf; memset(vis,0,sizeof(vis)); d[st]=0; q.push(make_pair(0,st)); while(q.size()) &#123; int x=q.top().second; q.pop(); if(vis[x]) continue; vis[x]=1; for(int i=first[x];i;i=nex[i]) &#123; int y=ver[i],z=edge[i]; if(d[x]!=inf&amp;&amp;z!=inf&amp;&amp;d[y]&gt;d[x]+z) &#123; d[y]=d[x]+z; q.push(make_pair(-d[y],y)); &#125; &#125; &#125; return;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;str); for(int i=1;i&lt;=m;i++) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); add_edge(i,a,b,c); &#125; dijkstra(str); for(int i=1;i&lt;=n;i++) printf("%d ",d[i]&gt;=inf?2147483647:d[i]); return 0;&#125; 这货我还看错题把无法到达的情况写炸了一次 堆优化之后，Dijkstra的复杂度优化到了不错的$O((n+m)logn)$，相当好使。 Part 3 SPFASPFA是一种非常高效的单源最短路算法，与DJ不同的是，它可以解决有负边的情况甚至可以判负环。 它其实是一个叫做Bellman-Ford的算法的队列优化版本。 话说BF算法让我想到了一个叫做BrainF**k的神仙语言 它采用的并非贪心算法，所以不会像Dijkstra一样被负边卡掉。 值得一提的是，作为一个优化后算法，他是可以被卡成B-F算法的$O(nm)$的。 卡掉它的方法是画一张菊花图。 算法的基本流程如下： 初始化。d[i]数组除了源点设成0其它全部设inf。 新建一个队列，源点入队，标记源点已经入队。 队首pop一个点，删除它的标记，对所有与当前出队点相邻的点作更新操作。 如果队列中没有这个点，就打好标记。 直到队列空掉为止。 简单易懂，实现也很简单。仍然使用邻接表存储。 代码如下：123456789101112131415161718192021222324void spfa(int st)&#123; for(int i=1;i&lt;=n;i++) d[i]=inf; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; vis[st]=1,d[st]=0; q.push(st); while(!q.empty()) &#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=first[x];i;i=nex[i]) &#123; int y=ver[i],z=edge[i]; if(d[y]&gt;d[x]+z) &#123; d[y]=d[x]+z; if(vis[y]==0) q.push(y),vis[y]=1; &#125; &#125; &#125; return; //return讲究&#125; 放一份可以AC洛谷模板题（弱化版）的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int inf=1e9+7;int n,m,str;int d[10005];bool vis[10005];int first[10005],nex[500005],ver[500005],edge[500005];void add_edge(int num,int u,int v,int l)&#123; ver[num]=v; edge[num]=l; nex[num]=first[u]; first[u]=num; return;&#125;void spfa(int st)&#123; for(int i=1;i&lt;=n;i++) d[i]=inf; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; vis[st]=1,d[st]=0; q.push(st); while(q.size()) &#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=first[x];i;i=nex[i]) &#123; int y=ver[i],z=edge[i]; if(d[y]&gt;d[x]+z) &#123; d[y]=d[x]+z; if(vis[y]==0) q.push(y),vis[y]=1; &#125; &#125; &#125; return; &#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;str); for(int i=1;i&lt;=m;i++) &#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); add_edge(i,a,b,c); &#125; spfa(str); for(int i=1;i&lt;=n;i++) printf("%d ",d[i]&gt;=inf?2147483647:d[i]); return 0;&#125; 结束语最短路的三种基本算法大概就复习得差不多了。 剩下的就是去多做题就好。]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假科学研究性学习报告]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%9A%91%E5%81%87%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[光在曲面上的折射与反射7203 马正陌 暑期研究性学习报告 背景阐述学初一下学期第二单元时，学习了有关于反射与折射的知识。当时老师在画光路图的时候，给了一个结论： 作光路图时，对于一个半圆形的透明玻璃块，从它的圆心射入的光线会不受折射，原样射出。 在学习漫反射的过程中，老师在一个球面上画的光路图也似乎有一些特殊的性质。 由于没有学过光在曲面上的反射性质，觉得非常神奇。于是把研究性学习的题目定为光在曲面上的折射与反射。 初步想法想法其实在老师刚刚讲完特殊折射时就已经有了。 因为反射和折射都基于一个平面来进行，认为曲面上的折射与反射也应该有自己的一个“假想平面”。既然最简单的例子是球形，那么，第一个念头就是：切面。 这个假设至少是具有几何美的。只过一个切点的面，很可能就是光的反/折射面。这个切点也只能是光线照射的那个点。 解决的办法是：先从一些简单的曲面着手（例如球面、抛物面）开始实验，然后进行假设的验证和推广。 科学原理光在均匀介质中的传播性质。 实验方案 反射实验采用一个绘有极坐标系的板与弯曲的条状面镜来做。 折射实验采用一个绘有极坐标系的板与半圆形玻璃砖来做。 成果展示：数据器材有限，均以球面镜为准。 数据均三次测量取平均值。 凹面镜 入射角 反射角 15° 15° 30° 30° 45° 45° 60° 60° 75° 75° 90° 90° 凸面镜 入射角 反射角 15° 15° 30° 30° 45° 45° 60° 60° 75° 75° 90° 90° 凹透镜 入射角 反射角 15° 15° 30° 30° 45° 45° 60° 60° 75° 75° 90° 90° 凸透镜 入射角 反射角 15° 15° 30° 30° 45° 45° 60° 60° 75° 75° 90° 90° 成果展示：推论首先发现的是曲面上的折射与反射光线仍与入射光线处于同一平面内。 既然处于同一平面内，那么就可以使用一个平面直角坐标系来描述。 注意到“假想面”是切面（放到光线所在平面内就是切线），那么有以下推论： 设原曲线为$f(x)$，它的导函数为$f’(x)$ 设入射光线与原曲线交点为$(x_0,y_0)$，则切线的斜率为$f’(x_0)$ 则容易求得过$x_0$的切线的表达式为$y=f’(x_0)x+y_0-f’(x_0)x_0$ 则法线的表达式为$y=\frac{1}{f’(x_0)}x+y_0-f’(x_0)x_0$ 已知入射角$\alpha$，则根据法线和折射率$k$可以作出反射角$\beta$和折射角$\gamma$ 这里有$\beta=\alpha$，$\gamma=\alpha{k}$ 以上为在平面内作光路图的一般作法。 研究后反思]]></content>
      <tags>
        <tag>science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于链式前向星的笔记]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%85%B3%E4%BA%8E%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E7%9A%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[链式前向星学习笔记链式前向星是一种非常常见且高效的一种存图方法，在LCA/SPFA等算法中很常用，由于我太弱了，所以需要写一篇Blog来理解它的用法。 需要申明的数组End[i]:第i号边指向的点 Len[i]：第i号边的长度 Next[i]：跟第i号边有相同起点的上一条边的编号 Last[x]：以x为起点的最新一条边的编号 注 ： 在End[i]、Next[i]和Len[i]中，i表示的是第i号边， 而在Last[x]中，x表示的是第x号点； 在Next[i]和Last[x]中存的是边的编号，而在End[i]中存的是点的编号； 边的编号由输入顺序决定，点的编号由输入数据决定； 此处均以有向图讨论，无向图只需要将一条边拆分成两条有向边来存即可； 所有数组的初值均赋为0。 CODE TIME!存图代码：1234567891011//输入n，下面n行输入三个数字，x，y，z，表示从x到y有一条长度为z的边scanf("%d",&amp;n);for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); End[i] = y; Len[i] = z; Next[i] = Last[x];//注意此行与下一行的顺序 //因为Last[i]存的是以x为起点的上一条最新的边，所以此时以x为起点是上一条边 == 目前的Last[x] Last[x] = i;//更新，保证Last[i]始终存的是最新一条边的编号&#125; 输出从点x出发的边:1234567int i=Last[x];//找到最新的一条以x为起点的边 while(i) &#123; //如果有以x为起点的边，则i != 0，则循环继续 printf("%d%d%d\n",x,End[i],Len[i]);//输出起点，终点，长度 i=Next[i];//将i更新为同i一个起点的上一条边，直到 i==0（没有上一条边，循环结束） //若i!=0，则循环继续 &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[寒露]]></title>
    <url>%2F2019%2F03%2F10%2F%E5%AF%92%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[正文你好，寒露。秋天的一个早上，我在校园的小路忽然与你相遇。你在披针形草叶末梢一颗半凝的霜露里，你在迎面吹来的乍寒的晨风里，你在从梧桐树上旋转着落下的一片枯叶里。你带着嗖嗖的寒意，让我把手插在裤兜里，不想和你打个招呼。“坏天气为什么这么早就到来了啊！”我甚至这么想，紧了紧校服外套。我还在怀念着夏天的明亮与热烈，到海边去的碧海蓝天与欢乐时光，想念着冰淇凌和西瓜。——就像不知道为什么，才刚刚算是迈进少年，我就开始怀念童年。 你好，寒露。走在校园的小路上，我有那么点儿“思绪万千”。我从小读着“秋天来了，大雁往南飞，一会儿排成一个一字，一会儿排成一个人字”，但其实，我从来没见过真正的大雁在天空飞。我对很多事情的理解，都很直接地进入了抽象概念。就像你，当我把校服紧一紧时，我想的是：“寒露，你是二十四节气中的第十七个。”但是你不服从我的数学总结，你是那么执着地提醒我的感官：温度低，湿度高。虽然我的手插在兜里，但是你沾在我的鼻尖上，让我忍不住打了个喷嚏。 你好，寒露。我觉得在你清肃的外表下，是不是也藏着点儿调皮？你是不是发现了我的偏见，并且下决心提醒我：时间的每一段，每一格，乃至每个无限小的点，都有它们各自的美和意义？夏天是无忧无虑的，而秋天是清醒冷静的。你把感受引向思考，引向环环迭代的澄思寂虑；而不是引向沉迷，引向层层嵌套的醉生梦死。我想起读过的里尔克的诗：“谁此时没有房子，就不必建造 / 谁此时孤独，就永远孤独”，还想起些关于寒露的中国古诗，它们也表现了孤独，以及思念。人总是必须在孤独中寻找自我，也必须在思念中寻找同类。 你好，寒露。秋天的一个早上，我在校园的小路里忽然与你相遇。我现在有点抱歉说你是“坏天气”了，我来了个深呼吸，把自己卷进晚秋清寒的空气。太阳升起，阳光一转眼就要收走草叶上的那颗凝露。时间是一个铁面无私的家伙，它无情地剥夺一切的存在：不止是一颗露珠，还有生命，还有记忆，思想……然而，我们的文化创造出一根美丽的标尺来丈量它，不试图违抗，不试图扭转，而是以一种审美的态度面对自己在时间面前脆弱的一生。 你好，寒露。谢谢你给我的这个美好早晨，那么，就让我把这些“思绪”记下，作为送给你的一份，小小礼物。 To：各位看官修改完毕，基本上定稿了。我的文笔实在挺烂的。希望没有辣到你们的眼睛（请勿ctrl+A&amp;ctrl+C生而为人，我很抱歉]]></content>
      <tags>
        <tag>Essays</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I'm Here now!]]></title>
    <url>%2F2019%2F03%2F09%2FI-m-Here-now%2F</url>
    <content type="text"><![CDATA[emmmm…I’m just here =)I’m the most stupid student all over the world!哦不好水啊]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
</search>
